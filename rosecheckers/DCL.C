/*
// <legal>
// CERT Rosecheckers
// Copyright 2022 Carnegie Mellon University.
// NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING INSTITUTE MATERIAL IS FURNISHED ON AN 'AS-IS' BASIS. CARNEGIE MELLON UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT, TRADEMARK, OR COPYRIGHT INFRINGEMENT.
// Released under a BSD (SEI)-style license, please see license.txt or contact permission@sei.cmu.edu for full terms.
// [DISTRIBUTION STATEMENT A] This material has been approved for public release and unlimited distribution.  Please see Copyright notice for non-US Government use and distribution.
// CERT(R) is registered in the U.S. Patent and Trademark Office by Carnegie Mellon University.
// This Software includes and/or makes use of Additional Software Dependencies, each subject to its own license.
// DM21-0505
// </legal>
 */

/**
 * \file DCL.C
 */

#include "rose.h"
#include "utilities.h"
#include "utilities_cpp.h"
#include <boost/regex.hpp>
#include <math.h>
#include <list>
#include <string>
#include <cstring>

/**
 * Const-qualify immutable objects
 *
 * \todo count assignments, if only one, report violation
 */
bool DCL00_C(const SgNode *node ) {
  const SgInitializedName *varName = isSgInitializedName(node);
  if (!varName)
    return false;

  /**
   * Ignore variables generated by macros
   */
  if ((varName->get_name().getString().substr(0,2) == "__")
      ||  isCompilerGeneratedNode(node))
    return false;

  /**
   * Ignore global variables
   */
  if (isGlobalVar(varName))
    return false;

  /**
   * Ignore variables that are already const, are function pointers, or are
   * declared inside of a struct, enum, or as an argument to a function
   */
  SgType *varType = varName->get_type();
  if (isConstType(varType)
      || isConstType(varType->dereference())
      || isConstType(varType->dereference()->dereference())
      || isSgFunctionType(varType)
      || isSgClassType(varType)
      || findParentOfType(varName, SgCtorInitializerList)
      || findParentOfType(varName, SgEnumDeclaration)
      || findParentOfType(varName, SgClassDeclaration))
    return false;

  /**
   * DCL13-C is a subset of this rule, figure out which rule we are dealing
   * with here
   */
  std::string ruleStr;
  std::string errStr;
  if (findParentOfType(varName, SgFunctionParameterList)) {
    /** ignore function prototypes, just worry about the definitions */
    const SgFunctionDeclaration *fnDecl = findParentOfType(varName, SgFunctionDeclaration);
    /**
     * Disabling assertion due to C++ code
     */
    if (!fnDecl)
      return false;
    //		assert(fnDecl);
    if (!fnDecl->get_definition())
      return false;
    if (isSgPointerType(varName->get_type())
        ||  isSgArrayType(varName->get_type())) {
      ruleStr = "DCL13-C";
      errStr = "Declare function parameters that are pointers to values not changed by the function as const: ";
    } else {
      return false;
    }
  } else {
    ruleStr = "DCL00-C";
    errStr = "Const-qualify immutable objects: ";
  }

  /**
   * Ignore global variables or variables declared as extern
   */
  const SgScopeStatement *varScope = varName->get_scope();
  if (isSgGlobal(varScope) || isExternVar(varName))
    return false;

  FOREACH_SUBNODE(varScope, nodes, i, V_SgVarRefExp) {
    const SgVarRefExp *iVar = isSgVarRefExp(*i);
    assert(iVar);
    if (getRefDecl(iVar) != varName)
      continue;

    const SgNode *parent = iVar->get_parent();
    while (isSgCastExp(parent)) {
      parent = parent->get_parent();
    }
    assert(parent);

    /**
     * If the variable is written to or it's address is taken, we can no
     * longer be sure it should be const, if it's a struct and gets
     * dereferenced, who knows what's getting written there :/
     */
    if (varWrittenTo(iVar)
        ||  isSgArrowExp(parent)
        ||  findParentOfType(iVar, SgAddressOfOp))
      return false;

    /**
     * If the variable is a pointer or array, and we pass it to a function
     * or as an argument to pointer arithmetic, or assign it's value
     * somewhere, we can longer be sure it should be const
     */
    if ((isSgPointerType(varType) || isSgArrayType(varType))
        && (findParentOfType(iVar, SgFunctionCallExp)
            || isSgAddOp(parent)
            || isSgSubtractOp(parent)
            || isSgAssignOp(parent)
            || isSgPntrArrRefExp(parent)
            || isSgPointerDerefExp(parent)
            || isSgAssignInitializer(parent)))
      return false;
  }

  const std::string msg =  errStr + varName->get_name().getString();
  print_error(node, ruleStr.c_str(), msg.c_str(), true);
  return true;
}

/**
 * Do not reuse variable names in subscopes
 */
bool DCL01_C(const SgNode *node ) {
  const SgInitializedName *varInitName = isSgInitializedName(node);
  if (!varInitName)
    return false;
  const SgName varName = varInitName->get_name();
  const SgScopeStatement *varScope = varInitName->get_scope();
  assert(varScope);
  while (!isSgGlobal(varScope)) {
    varScope = varScope->get_scope();
    if (varScope->symbol_exists(varName)) {
      print_error(node, "DCL01-C", ("Do not reuse variable names in subscopes: " + varName.getString()).c_str(), true);
      return true;
    }
  }

  return false;
}

std::string normalize_string(std::string str, bool isExtern) {
  size_t found;

  while ((found = str.find_first_of("1")) != std::string::npos)
    str[found] = 'l';
  while ((found = str.find_first_of("n")) != std::string::npos)
    str[found] = 'h';
  while ((found = str.find_first_of("0")) != std::string::npos)
    str[found] = 'O';
  while ((found = str.find_first_of("2")) != std::string::npos)
    str[found] = 'Z';
  while ((found = str.find_first_of("5")) != std::string::npos)
    str[found] = 'S';
  while ((found = str.find_first_of("8")) != std::string::npos)
    str[found] = 'B';

  unsigned int len = isExtern ? 31 : 63;

  if (str.size() > len)
    str = str.substr(0,len);

  return str;
}

void DCL02_report_error(const SgInitializedName *var) {
  unsigned int len = isExternVar(var) ? 31 : 63;
  std::string varStr = var->get_name().str();
  std::string ruleStr;
  std::string errStr;
  bool warning;
  if (varStr.size() > len) {
    ruleStr = "DCL23-C";
    errStr = "Guarantee that mutually visible identifiers are unique";
    warning = false;
  } else {
    ruleStr = "DCL02-C";
    errStr = "Use visually distinct identifiers";
    warning = true;
  }
  const std::string msg = errStr + ": " + varStr;
  print_error(var, ruleStr.c_str(), msg.c_str(), warning);
}

/**
 * Use visually distinct identifiers
 *
 * \note also checks DCL31-C
 */
bool DCL02_C(const SgNode *node ) {
  static std::map<const SgScopeStatement *, std::set<std::string> > scopeMap;
  static std::map<std::string, const SgInitializedName *> strVarMap;

  const SgScopeStatement *scope = isSgScopeStatement(node);
  if (!scope)
    return false;

  bool violation = false;

  if (isSgGlobal(scope)) {
    std::set<std::string> externNames;

    /** populate scopeMap */
    FOREACH_SUBNODE(scope, nodes, i, V_SgInitializedName) {
      SgInitializedName *var = isSgInitializedName(*i);
      assert(var);
      if (isCompilerGeneratedNode(var)
          || !isSgDeclarationStatement(var->get_parent())
          || findParentOfType(var, SgCtorInitializerList)
          || findParentOfType(var, SgClassDeclaration) // Might be too strong
          || var->get_name().getString().empty()
          || (var->get_name().getString().substr(0,2) == "__"))
        continue;

      /** Ignore function prototypes */
      const SgFunctionDeclaration * fnDecl = findParentOfType(var, SgFunctionDeclaration);
      if (fnDecl && !fnDecl->get_definition())
        continue;

      if (isExternVar(var)) {
        if (externNames.find(var->get_name().getString()) != externNames.end())
          continue;

        externNames.insert(var->get_name().getString());
      }

      const SgScopeStatement *varScope = var->get_scope();
      std::string str (normalize_string(var->get_name().str(), isExternVar(var)));
      if (scopeMap[varScope].find(str) != scopeMap[varScope].end()) {
        DCL02_report_error(var);
        violation = true;
      } else {
        scopeMap[varScope].insert(str);
        strVarMap[str] = var;
      }
    }
    return false;
  }

  std::set<std::string> ids;
  do {
    if (isCompilerGeneratedNode(scope))
      continue;
    for (std::set<std::string>::iterator i = scopeMap[scope].begin(); i != scopeMap[scope].end(); i++) {
      if (ids.find(*i) != ids.end()) {
        DCL02_report_error(strVarMap[*i]);
        violation = true;
      } else {
        ids.insert(*i);
      }
    }
  } while (!isSgGlobal(scope) && (scope = scope->get_scope()));

  return violation;
}

/**
 * Do not declare more than one variable per declaration
 */
bool DCL04_C(const SgNode *node ) {
  const SgVariableDeclaration *varDec = isSgVariableDeclaration(node);
  if (!varDec)
    return false;

  /**
   * \note Due to a bug in ROSE this comparison will always be false
   */
  if (varDec->get_variables().size() > 1) {
    print_error(node, "DCL04-C", "Do not declare more than one variable per declaration", true);
    return true;
  }

  return false;
}

static unsigned int DCL05_score(const SgType *t) {
  unsigned int score = 0;
  float var_points = 0;
  unsigned int modifiers = 0;
  const SgType *d = NULL;
  do {
    /** score modifiers because they add clutter */
    if (t->get_modifiers())
      modifiers += t->get_modifiers()->get_nodes().size();
    t = stripModifiers(t);

    /** obviously, typedefs should break us out */
    if (t != stripTypedefs(t))
      break;
    /** Count functions as two points */
    if (isSgFunctionType(t)) {
      SgTypePtrList &args = isSgFunctionType(t)->get_argument_list()->get_arguments();
      for (SgTypePtrList::iterator i = args.begin(); i != args.end(); i++) {
        score += DCL05_score(*i);
      }
      score+=2;
    }
    /** Arrays will derefence twice, so let's only score them once */
    //		if (isSgArrayType(t))
    //			score;
    /** score all other pointers as one point */
    if (isSgPointerType(t)) {
      var_points += 0.5;
    }
    /**
     * \bug ROSE is missing the const version of derefence()
     */
    d = const_cast<SgType *>(t)->dereference();
  } while ((t != d) && (t = d));

  return score + lrintf(var_points) + modifiers;
  //	return score;
}

/**
 * Use typedefs to improve code readability
 */
bool DCL05_C(const SgNode *node ) {
  const SgInitializedName *var = isSgInitializedName(node);
  const SgFunctionDeclaration *fn = isSgFunctionDeclaration(node);
  if (!(var || fn))
    return false;

  /**
   * Ignore function definitions
   */
  //	const SgDeclarationStatement *varDecl = var->get_declaration();
  //	assert(varDecl);
  //	if (isSgFunctionDeclaration(varDecl) && isSgFunctionDeclaration(varDecl)->get_definition())
  //		return false;

  const SgType *t = var ? var->get_type() : fn->get_type();
  assert(t);
  const unsigned int threshold = 4;
  unsigned int score = DCL05_score(t);
  if (score  >= threshold) {
    print_error(node, "DCL05-C", "Use typedefs to improve code readability", true);
    return true;
  }
  return false;
}

/**
 * Use the correct syntax for flexible array members
 */
bool DCL38_C(const SgNode *node ) {
	const SgClassDefinition* def = isSgClassDefinition(node);
	if (!def)
		return false;

  if (def->get_members().size() == 0)
    return false;
	const SgVariableDeclaration* varDecl = isSgVariableDeclaration(def->get_members().back());
	/**
	 * Disabling assertion due to C++ code
	 */
	if (!varDecl)
		return false;
  //	assert(varDecl);

	if (varDecl->get_variables().size() != 1)
		return false;

	const SgInitializedName *varName = varDecl->get_variables().front();
	assert(varName);

	const SgArrayType *arrT = isSgArrayType(varName->get_type());
	if (!arrT)
		return false;

	const SgValueExp* arrSize = isSgValueExp(arrT->get_index());
	if (!arrSize)
		return false;

	if (isVal(arrSize,0) || isVal(arrSize,1)) {
		print_error(varDecl, "DCL38-C", "Use the correct syntax when declaring flexible array members");
		return true;
	}
	return false;
}


/*************
 * CPP Rules *
 *************/

/* DCL10-CPP. Do not overload the ampersand, comma, logical AND or logical OR operators */
bool DCL10_CPP(const SgNode *node ) {
  if (const SgFunctionDeclaration *fd = isSgFunctionDeclaration(node ) ) {
    const std::string n = fd->get_name().getString();
    if (n == "operator&&" || n == "operator||" ) {
      print_error(fd, "DCL10-CPP", "Overloaded && or || operator", true);
      return true;
    }
    else if (n == "operator&" ) {
      int args = argCount(fd );
      bool isMember = isSgMemberFunctionDeclaration(fd );
      if ((isMember && args == 0) || (!isMember && args == 1) ) {
        print_error(fd, "DCL10-CPP", "Overloaded unary & operator", true);
        return true;
      }
    }
    if (n == "operator," ) {
      print_error(fd, "DCL10-CPP", "Overloaded , operator", true);
      return  true;
    }

  }
  return false;
}

/* DCL36-CPP. Do not declare an identifier with conflicting linkage classifications */
bool DCL36_CPP(const SgNode *node ) {
  if (const SgVariableDefinition *vdef = isSgVariableDefinition(node ) ) {
    //XXX get defining declaration?
    const SgDeclarationModifier &dm = vdef->get_declarationModifier();
    const SgStorageModifier &sm = const_cast<SgDeclarationModifier &>(dm).get_storageModifier();
    if (sm.isExtern() || sm.isUnknown() || sm.isUnspecified() ) { //XXX not so sure this is right...
      //XXX should also permit externs in anonymous namespaces
      const SgInitializedName *in = vdef->get_vardefn();
      const SgInitializer *init = in->get_initializer();
      bool runtimeInit = isSgConstructorInitializer(init );
      if (!runtimeInit ) {
        if (const SgAssignInitializer *ai = isSgAssignInitializer(init ) ) {
          const SgExpression *e = ai->get_operand_i();
          runtimeInit = !isSgValueExp(e );
        }
      }
      if (!runtimeInit ) {

        /*
          if (const SgAggregateInitializer *ai = isSgAggregateInitializer(init ) ) {
          //XXX need to check aggregates
          }
        */
      }

      if (runtimeInit ) {
        print_error(node, "DCL36-C", "Runtime static initialization of object with external linkage", false);
        return true;
      }
      else {
        // To avoid a plethora of messages, check for runtime static destruction
        // only if there was no flagging of initialization.
        // See if the type of the object being defined has a non-trivial dtor.
        const SgType *t = in->get_type();
        t = t->stripType(SgType::STRIP_TYPEDEF_TYPE );
        if (const SgClassType * ct = isSgClassType(t ) ) {
          const SgDeclarationStatement *decl = ct->get_declaration();
          const SgClassDeclaration *cdecl = isSgClassDeclaration(decl );
          if (const SgClassDefinition *cdef = cdecl->get_definition() ) {
            const SgDeclarationStatementPtrList &members = cdef->get_members();
            for (SgDeclarationStatementPtrList::const_iterator i = members.begin(); i != members.end(); ++i ) {
              if (const SgFunctionDeclaration *fdec = isSgFunctionDeclaration(*i ) ) {
                if (fdec->get_specialFunctionModifier().isDestructor() ) {
                  print_error(node, "DCL36-C", "Runtime static initialization of object with external linkage.", false);
                  return true;
                }
              }
            }
          }
        }
      }
    }
  }
  return false;
}


/***************************
 * Violation checking code *
 ***************************/

bool DCL_C(const SgNode *node) {
  bool violation = false;
  violation |= DCL00_C(node);
  violation |= DCL01_C(node);
  violation |= DCL02_C(node);
  violation |= DCL04_C(node);
  violation |= DCL05_C(node);
  violation |= DCL38_C(node);
  return violation;
}



/// C++ checkers

bool DCL_CPP(const SgNode *node) {
  bool violation = false;
  violation |= DCL10_CPP(node);
  violation |= DCL36_CPP(node);
  violation |= DCL_C(node);
  return violation;
}
